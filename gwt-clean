#!/usr/bin/env bash
#
# gwt-clean - Remove ephemeral worktrees for the current repo
#
# Usage: gwt clean

set -e

# Colors
if [[ -t 1 ]]; then
    RED=$'\033[0;31m'
    GREEN=$'\033[0;32m'
    YELLOW=$'\033[0;33m'
    BLUE=$'\033[0;34m'
    BOLD=$'\033[1m'
    DIM=$'\033[2m'
    NC=$'\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' BOLD='' DIM='' NC=''
fi

show_usage() {
    cat <<EOF
${BOLD}gwt clean${NC} - Remove ephemeral worktrees

${BOLD}USAGE${NC}
    gwt clean [options]

${BOLD}OPTIONS${NC}
    -f, --force     Skip confirmation prompt
    -n, --dry-run   Show what would be removed without doing it
    --all           Clean ALL repos' ephemeral worktrees (not just current)
    --keep-branches Don't delete the branches

${BOLD}DESCRIPTION${NC}
    Removes ephemeral worktrees in ~/.worktrees for the CURRENT repo only.
    Use --all to clean worktrees from all repos.

    Ephemeral worktrees are named: <repo>--<branch>
    This command only removes those matching the current repo.

${BOLD}EXAMPLES${NC}
    gwt clean              # Clean current repo's ephemeral worktrees
    gwt clean --dry-run    # See what would be removed
    gwt clean --all        # Clean ALL ephemeral worktrees (all repos)

EOF
}

if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    show_usage
    exit 0
fi

# Parse arguments
force=false
dry_run=false
keep_branches=false
clean_all=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        -f|--force)
            force=true
            shift
            ;;
        -n|--dry-run)
            dry_run=true
            shift
            ;;
        --all)
            clean_all=true
            shift
            ;;
        --keep-branches)
            keep_branches=true
            shift
            ;;
        -*)
            echo -e "${RED}error:${NC} unknown option: $1" >&2
            exit 1
            ;;
        *)
            shift
            ;;
    esac
done

# Configuration
ephemeral_dir="${GWT_WORKTREE_DIR:-$HOME/.worktrees}"

# Get current repo name (unless --all)
repo_name=""
if [[ "$clean_all" == false ]]; then
    # Ensure we're in a git repo
    if ! git rev-parse --git-dir &>/dev/null; then
        echo -e "${RED}error:${NC} not a git repository" >&2
        echo -e "${DIM}hint:  use --all to clean all repos' worktrees${NC}" >&2
        exit 1
    fi

    # Find project root to get repo name
    find_project_root() {
        local dir=$(pwd)
        while [[ "$dir" != "/" ]]; do
            if [[ -d "$dir/.bare" ]]; then
                echo "$dir"
                return 0
            fi
            dir=$(dirname "$dir")
        done
        local wt_root
        wt_root=$(git rev-parse --show-toplevel 2>/dev/null) || return 1
        dirname "$wt_root"
    }

    project_root=$(find_project_root)
    if [[ -z "$project_root" ]]; then
        echo -e "${RED}error:${NC} could not determine project root" >&2
        exit 1
    fi
    repo_name=$(basename "$project_root")
fi

# Check if ephemeral directory exists
if [[ ! -d "$ephemeral_dir" ]]; then
    echo -e "${DIM}No ephemeral worktree directory found at ${ephemeral_dir}${NC}"
    echo -e "${DIM}Nothing to clean.${NC}"
    exit 0
fi

# Find matching worktrees in ephemeral dir
worktrees=()
branches=()

for dir in "$ephemeral_dir"/*/; do
    if [[ -d "$dir" ]]; then
        dir_name=$(basename "$dir")

        # If not --all, filter by repo name prefix
        if [[ "$clean_all" == false ]]; then
            # Worktrees are named: <repo>--<branch>
            if [[ "$dir_name" != "${repo_name}--"* ]]; then
                continue
            fi
        fi

        # Check if it's a git worktree
        if [[ -f "${dir}.git" ]] || [[ -d "${dir}.git" ]]; then
            worktrees+=("${dir%/}")
            # Try to get branch name
            branch=$(git -C "$dir" branch --show-current 2>/dev/null || echo "")
            branches+=("$branch")
        fi
    fi
done

if [[ ${#worktrees[@]} -eq 0 ]]; then
    if [[ "$clean_all" == true ]]; then
        echo -e "${DIM}No ephemeral worktrees found in ${ephemeral_dir}${NC}"
    else
        echo -e "${DIM}No ephemeral worktrees found for '${repo_name}'${NC}"
    fi
    echo -e "${DIM}Nothing to clean.${NC}"
    exit 0
fi

# Show what will be removed
echo ""
if [[ "$clean_all" == true ]]; then
    echo -e "${BOLD}Ephemeral worktrees to remove (ALL repos):${NC}"
else
    echo -e "${BOLD}Ephemeral worktrees to remove for '${repo_name}':${NC}"
fi
echo ""
for i in "${!worktrees[@]}"; do
    wt="${worktrees[$i]}"
    branch="${branches[$i]}"
    if [[ -n "$branch" ]]; then
        echo -e "  ${YELLOW}${branch}${NC}"
        echo -e "    ${DIM}${wt}${NC}"
    else
        echo -e "  ${DIM}(detached)${NC}"
        echo -e "    ${DIM}${wt}${NC}"
    fi
done
echo ""
echo -e "${DIM}${#worktrees[@]} worktree(s) will be removed${NC}"
echo ""

# Dry run stops here
if [[ "$dry_run" == true ]]; then
    echo -e "${YELLOW}Dry run - no changes made${NC}"
    exit 0
fi

# Confirm unless forced
if [[ "$force" != true ]]; then
    echo -n -e "Proceed? [y/N] "
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        echo -e "${DIM}Cancelled.${NC}"
        exit 0
    fi
    echo ""
fi

# Remove worktrees
removed=0
failed=0

echo -e "${BLUE}::${NC} Removing ephemeral worktrees..."
echo ""

for i in "${!worktrees[@]}"; do
    wt="${worktrees[$i]}"
    branch="${branches[$i]}"
    wt_name=$(basename "$wt")

    # Find which repo this worktree belongs to and remove properly
    if git -C "$wt" worktree list &>/dev/null; then
        if git -C "$wt" worktree remove --force "$wt" 2>/dev/null; then
            echo -e "  ${GREEN}removed${NC} $wt_name"
            removed=$((removed + 1))

            # Delete branch if requested
            if [[ "$keep_branches" == false ]] && [[ -n "$branch" ]]; then
                # We need to find another worktree of the same repo to delete the branch
                # This is tricky, so we'll just note it
                :
            fi
        else
            echo -e "  ${RED}failed${NC}  $wt_name"
            failed=$((failed + 1))
        fi
    else
        # Not a valid worktree, just remove directory
        rm -rf "$wt"
        echo -e "  ${GREEN}removed${NC} $wt_name (orphaned)"
        removed=$((removed + 1))
    fi
done

# Prune all repos that had worktrees
echo ""
echo -e "${BLUE}::${NC} Pruning stale worktree references..."

# Find all git directories that might have had worktrees here
find "$ephemeral_dir" -name ".git" -type f 2>/dev/null | while read -r gitfile; do
    if [[ -f "$gitfile" ]]; then
        gitdir=$(cat "$gitfile" | grep "gitdir:" | cut -d' ' -f2)
        if [[ -n "$gitdir" ]]; then
            main_git=$(dirname "$gitdir")
            main_git=$(dirname "$main_git")
            if [[ -d "$main_git" ]]; then
                git -C "$main_git" worktree prune 2>/dev/null || true
            fi
        fi
    fi
done

# Clean up empty ephemeral directory
remaining=$(find "$ephemeral_dir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l | tr -d ' ')
if [[ "$remaining" == "0" ]]; then
    rmdir "$ephemeral_dir" 2>/dev/null || true
fi

echo ""
echo -e "${GREEN}Done.${NC} Removed $removed worktree(s)."

if [[ $failed -gt 0 ]]; then
    echo -e "${YELLOW}$failed worktree(s) could not be removed.${NC}"
    exit 1
fi
